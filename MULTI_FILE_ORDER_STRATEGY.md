# Переход от 1 файла к 2+ файлам на заказ

## 1) Текущая ситуация (as-is)
Сейчас модель заказа фактически однофайловая:
- `OrderData` хранит по одному пути на стадию: `SourcePath`, `PreparedPath`, `PrintPath`.
- Большая часть UI и операций (`переименование`, `копирование`, `удаление`, drag&drop, контекстное меню) работает с «одним активным файлом» на колонку.
- Процессор (`OrderProcessor`) также ожидает единичные вход/выход пути.

Итог: поддержка 2+ файлов требует не «точечного патча», а согласованного решения по модели данных, UX и пайплайну обработки.

---

## 2) Какие варианты реализации есть

## Вариант A — Быстрый (минимум изменений): «Главный файл + вложения»

### Идея
Оставить текущие поля как **Primary** (главный файл), а дополнительные файлы хранить отдельным списком как «вложения заказа».

### Что меняется
- В `OrderData` добавить коллекцию `Attachments` (path + stage + метаданные).
- Существующий пайплайн продолжает работать только по `Primary` путям.
- В UI добавить доступ к вложениям (кнопка/диалог в строке заказа).

### Плюсы
- Самый быстрый выход.
- Минимальный риск сломать текущую обработку.

### Минусы
- «Неполноценная» многофайловость: автоматизация остаётся по одному файлу.
- Оператору нужно вручную выбирать, какой файл главный.

### Когда выбирать
Если нужно быстро дать пользователю «хранить 2+ файла», но без полной автоматизации пакетов.

---

## Вариант B — Сбалансированный (рекомендуемый): «Файлы заказа как коллекция + выбранный активный»

### Идея
Перевести заказ на коллекционную модель: на каждой стадии может быть несколько файлов, но есть понятие **active file** для автопроцесса.

### Что меняется
- Новая сущность `OrderFile`:
  - `Id`
  - `Stage` (`Source|Prepared|Print`)
  - `Path`
  - `DisplayName`
  - `IsActive`
  - `Status` (опционально, per-file)
  - `CreatedAt`/`UpdatedAt`
- В `OrderData`:
  - `List<OrderFile> Files`
  - для обратной совместимости оставить старые поля и вычислять их из `IsActive`.
- В UI:
  - в колонке показывать `N файлов` + активный,
  - двойной клик открывает окно файлов стадии,
  - действия контекстного меню выполняются по выбранному файлу.
- В процессоре:
  - по умолчанию работает с `IsActive` файлом,
  - опция «обработать все активные/все файлы стадии» — позже.

### Плюсы
- Реальная многофайловость без мгновенного полного рефакторинга процессора.
- Мягкая миграция: старый код можно сохранить на переходный период.

### Минусы
- Заметный объём изменений в UI и сериализации.
- Нужно продумать поведение «активного файла» и его выбор.

### Когда выбирать
Лучший компромисс на ближайшие релизы, если нужна рабочая 2+ модель в продукте.

---

## Вариант C — Полный рефакторинг: «Пакетная обработка по всем файлам стадии»

### Идея
Заказ обрабатывается как набор файлов, процессор работает циклом/пакетом (batch), статусы и ошибки — по каждому файлу + агрегированный по заказу.

### Что меняется
- Полный переход на `OrderFile` как первичную модель.
- `OrderProcessor` умеет:
  - serial/parallel обработку,
  - retries,
  - пер-файловые таймауты,
  - частичный успех.
- Статусы:
  - `OrderStatus` (aggregate)
  - `FileStatus` (per item)
- UI:
  - детальная таблица файлов заказа,
  - фильтры «ошибки/готово/в работе» на уровне файлов.

### Плюсы
- Максимально корректная архитектура для масштабирования.
- Готовность к большим заказам и SLA.

### Минусы
- Самая высокая стоимость и риск сроков.
- Требует серьёзного тестового покрытия.

### Когда выбирать
Если цель — полноценный «production-grade batch product» с ростом нагрузки.

---

## 3) Решения, которые нужно принять до разработки

1. **Что считать единицей обработки:** заказ или файл?
2. **Нужен ли активный файл на стадию** (как fallback), или всегда пакет?
3. **Как считать статус заказа** при частичном успехе (например, 8/10 готово)?
4. **Как нумеровать/именовать итоговые print-файлы** при множественных входах?
5. **Какой режим по умолчанию:** обрабатывать активный или все файлы?
6. **Нужны ли лимиты** на число файлов/размеры?
7. **Нужна ли параллельная обработка** и с каким ограничением потоков?
8. **Как мигрируем старую историю (`history.json`)** в новую структуру?

---

## 4) Рекомендуемый путь (практично)

Рекомендую **Вариант B** как основной, в 3 шага:

### Шаг 1 — Data Foundation
- Ввести `OrderFile` + `List<OrderFile>` в `OrderData`.
- Сохранить совместимость со старыми полями (`SourcePath`/`PreparedPath`/`PrintPath`) как view/fallback.
- Добавить миграцию при загрузке: если старые поля есть, создать по одному `OrderFile` на стадию.

### Шаг 2 — UI Foundation
- Добавить модальное окно «Файлы заказа» (по стадиям).
- Поддержать операции: добавить/удалить/выбрать active/переименовать.
- В гриде показывать индикатор количества файлов и активный файл.

### Шаг 3 — Processor Bridge
- Обновить `OrderProcessor` так, чтобы он работал с active-файлом через новую модель.
- Добавить режим (флаг) «обработать все файлы стадии» как экспериментальный.

Это даст рабочую многофайловость быстро и безопасно, с ясным мостом к Варианту C.

---

## 5) План работ (итерации)

## Итерация 1 (1–2 спринта)
- Модель `OrderFile`, миграция JSON, базовый UI для списка файлов, active-file.
- Совместимость с текущим обработчиком.

## Итерация 2
- Пакетные действия по стадии (массовый импорт, массовое удаление, массовая валидация).
- Улучшение логов: per-file и summary per-order.

## Итерация 3
- Полный batch-режим (по желанию): обработка нескольких файлов, частичный успех, retry policy.

---

## 6) Риски и как снизить

1. **Ломаем обратную совместимость истории.**
   - Митигация: lazy-migration при `LoadHistory`, бэкап `history.json.bak`.

2. **Сложный UX при множестве файлов.**
   - Митигация: сначала модальное окно + active-file, без перегруза главной таблицы.

3. **Рост числа пограничных ошибок в статусах.**
   - Митигация: отдельно хранить `OrderStatus` и `FileStatus`, логировать переходы по обоим уровням.

4. **Производительность на больших заказах.**
   - Митигация: лимиты, ленивый рендер списков, батчевые операции.

---

## 7) Уточняющие вопросы

1. В одном заказе файлы обычно относятся к **одному изделию** или к **разным позициям**?
2. Нужна ли сквозная связка «исходный -> подготовка -> печать» для **каждого** файла?
3. При 5 файлах в заказе запуск обработки должен идти:
   - только по active,
   - по всем,
   - с выбором перед запуском?
4. Допускается ли частичный статус типа «⚠ Частично готово (3/5)»?
5. Нужна ли сортировка/группировка файлов внутри заказа (по имени, дате, формату)?
6. Нужны ли массовые операции (применить PitStop/Imposing ко всем)?
7. Есть ли типичный максимум файлов на заказ (2–5, 10–20, 100+)?
8. Нужен ли запрет на дубликаты имён в рамках стадии?
9. Нужно ли хранить «основной файл для клиента» отдельно от «технических файлов»?
10. Какой вариант приоритетен по срокам: быстро (A), сбалансированно (B), полно (C)?

---

## 8) Короткий вывод
- Если задача «уже сейчас поддержать 2+ файла без риска» — **Вариант A**.
- Если нужен правильный путь в продукт с умеренной сложностью — **Вариант B (рекомендован)**.
- Если цель — полноценный масштабируемый batch-продукт — **Вариант C**.
